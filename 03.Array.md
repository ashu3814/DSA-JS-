

# JavaScript Arrays - Comprehensive Notes  Î∞∞Ïó¥

## üìú Table of Contents
- [1. What is an Array? üßê](#1-what-is-an-array-%F0%9F%A7%90)
- [2. Creating Arrays üõ†Ô∏è](#2-creating-arrays-%F0%9F%9B%A0%EF%B8%8F)
  - [Array Literal `[]` ‚ú®](#array-literal--%E2%9C%A8)
  - [`Array` Constructor `new Array()` üèóÔ∏è](#array-constructor-new-array--%F0%9F%8F%9D%EF%B8%8F)
- [3. Array Type üè∑Ô∏è](#3-array-type-%F0%9F%8F%B7%EF%B8%8F)
  - [`typeof` Operator](#typeof-operator)
  - [`Array.isArray()` Check ‚úÖ](#arrayisarray-check-%E2%9C%85)
- [4. Accessing and Modifying Elements üéØ](#4-accessing-and-modifying-elements-%F0%9F%8E%AF)
  - [Accessing Elements](#accessing-elements)
  - [Modifying Elements](#modifying-elements)
  - [`.length` Property üìè](#length-property-%F0%9F%93%8F)
- [5. Copying Arrays üêëüêë](#5-copying-arrays-%F0%9F%90%91%F0%9F%90%91)
  - [Why Copy? ü§î](#why-copy-%F0%9F%A4%94)
  - [Shallow Copy Methods ÏñïÏùÄ Î≥µÏÇ¨](#shallow-copy-methods-%EC%96%95%EC%9D%80-%EB%B3%B5%EC%82%AC)
    - [Spread Syntax (`...`) ‚ú®](#spread-syntax--%E2%9C%A8)
    - [`slice()` Method for Copying üç∞](#slice-method-for-copying-%F0%9F%AA%81)
    - [`Array.from()` Method for Copying üè≠](#arrayfrom-method-for-copying-%F0%9F%8F%AD)
  - [Note on Deep Copy üåä (vs. ÏñïÏùÄ)](#note-on-deep-copy-%F0%9F%8C%8A-vs-%EC%96%95%EC%9D%80)
- [6. Iterating Over Arrays üö∂‚Äç‚ôÄÔ∏èüö∂‚Äç‚ôÇÔ∏è](#6-iterating-over-arrays-%F0%9F%9A%B6%E2%80%8D%E2%99%80%EF%B8%8F%F0%9F%9A%B6%E2%80%8D%E2%99%82%EF%B8%8F)
  - [`for` Loop (Traditional) klasik](#for-loop-traditional-klasik)
  - [`for...of` Loop (ES6) üî•](#forof-loop-es6-%F0%9F%94%A5)
  - [`forEach()` Method for Iteration üîÑ](#foreach-method-for-iteration-%F0%9F%94%84)
- [7. Common Array Methods ‚öôÔ∏è](#7-common-array-methods-%E2%9A%99%EF%B8%8F)
  - [Mutator Methods (Modify the Original Array) üí•](#mutator-methods-modify-the-original-array-%F0%9F%92%A5)
    - [`push()`](#push)
    - [`pop()`](#pop)
    - [`shift()`](#shift)
    - [`unshift()`](#unshift)
    - [`splice()`](#splice)
    - [`sort()`](#sort)
    - [`reverse()`](#reverse)
    - [`fill()`](#fill)
  - [Accessor Methods (Return New Array/Value, Don't Modify Original) üõ°Ô∏è](#accessor-methods-return-new-arrayvalue-dont-modify-original-%F0%9F%9B%A1%EF%B8%8F)
    - [`slice()`](#slice)
    - [`concat()`](#concat)
    - [`join()`](#join)
    - [`indexOf()`](#indexof)
    - [`lastIndexOf()`](#lastindexof)
    - [`includes()` (ES7)](#includes-es7)
  - [Iteration Methods (Often Involve Callbacks) üßë‚Äçü§ù‚Äçüßë](#iteration-methods-often-involve-callbacks-%F0%9F%A7%91%E2%80%8D%F0%9F%A6%AF%F0%9F%A7%91%E2%80%8D%F0%9F%A6%BD%E2%80%8D%F0%9F%A6%B0%F0%9F%A7%91%E2%80%8D%F0%9F%A6%BD%E2%80%8D%F0%9F%A6%B3)
    - [`forEach()`](#foreach)
    - [`map()`](#map)
    - [`filter()`](#filter)
    - [`find()` (ES6)](#find-es6)
    - [`findIndex()` (ES6)](#findindex-es6)
    - [`every()`](#every)
    - [`some()`](#some)
    - [`reduce()`](#reduce)
    - [`reduceRight()`](#reduceright)
    - [`flat()` (ES2019)](#flat-es2019)
    - [`flatMap()` (ES2019)](#flatmap-es2019)
  - [Static Methods (Called on `Array` itself) üèõÔ∏è](#static-methods-called-on-array-itself-%F0%9F%8F%9B%EF%B8%8F)
    - [`Array.from()`](#arrayfrom)
    - [`Array.isArray()` (Static)](#arrayisarray-static)
    - [`Array.of()` (ES6)](#arrayof-es6)
- [8. Advanced Array Concepts (Briefly) üåå](#8-advanced-array-concepts-briefly-%F0%9F%8C%8C)
  - [Multi-dimensional Arrays ‚ñ¶](#multi-dimensional-arrays-%F0%9F%AA%A8)
  - [Sparse Arrays üï≥Ô∏è](#sparse-arrays-%F0%9F%95%B3%EF%B8%8F)

---

## 1. What is an Array? üßê

An **Array** in JavaScript is a special type of object used to store an ordered collection of multiple values (elements) under a single variable name.

**Key Characteristics:**
*   üì¶ **Ordered Collection:** Elements are stored in a specific sequence, and this order is maintained.
*   üî¢ **0-indexed:** The first element is at index `0`, the second at index `1`, and so on.
*   ‚ÜîÔ∏è **Dynamic Size:** Arrays can grow or shrink in size dynamically. You don't need to specify the size beforehand.
*   üß© **Mixed Data Types:** An array can hold elements of different data types (numbers, strings, booleans, objects, other arrays, etc.) in the same array.

```javascript
let mixedArray = [10, "hello", true, { name: "Alice" }, [1, 2]];
```

## 2. Creating Arrays üõ†Ô∏è

There are two primary ways to create arrays in JavaScript:

### Array Literal `[]` ‚ú®

This is the most common and preferred way to create an array.

üëç Pros: Concise, readable, less prone to errors.

Syntax:
```javascript
let arrayName = [element1, element2, ..., elementN];
let emptyArray = [];
```

Example:
```javascript
let fruits = ["Apple", "Banana", "Cherry"]; // Array of strings
let numbers = [1, 2, 3, 4, 5];             // Array of numbers
let empty = [];                            // An empty array

console.log(fruits);   // Output: ["Apple", "Banana", "Cherry"]
console.log(numbers);  // Output: [1, 2, 3, 4, 5]
console.log(empty);    // Output: []
```

### `Array` Constructor `new Array()` üèóÔ∏è

You can also create arrays using the `Array` constructor.

ü§î Considerations:
*   Can be slightly more verbose.
*   Has a special behavior with a single numeric argument that can be confusing.

Syntax:
```javascript
// With multiple elements
let arrayName1 = new Array(element1, element2, ..., elementN);

// Empty array
let arrayName2 = new Array(); // Same as []

// ‚ö†Ô∏è With a single numeric argument (creates an array of that length with empty/undefined slots)
let arrayName3 = new Array(arrayLength);
```

Examples:
```javascript
let colors = new Array("Red", "Green", "Blue");
console.log(colors); // Output: ["Red", "Green", "Blue"]

let emptyWithConstructor = new Array();
console.log(emptyWithConstructor); // Output: []

// ‚ö†Ô∏è Caution: Single numeric argument behavior
let sizedArray = new Array(5); // Creates an array with length 5, elements are <empty slots>
console.log(sizedArray);       // Output: [ <5 empty items> ]
console.log(sizedArray.length); // Output: 5
console.log(sizedArray[0]);    // Output: undefined

// To create an array with a single numeric element:
let singleNumberArray1 = [10];
// let singleNumberArray2 = new Array(10); // This creates an array of length 10, NOT an array with element 10
let singleNumberArray3 = Array.of(10);  // Correct way with constructor-like syntax for single number

console.log(singleNumberArray1); // Output: [10]
// console.log(singleNumberArray2); // Output: [ <10 empty items> ]
console.log(singleNumberArray3); // Output: [10]
```

üí° Recommendation: Prefer array literals `[]` for most cases due to their simplicity and to avoid the ambiguity of `new Array(number)`. Use `Array.of()` if you need to create an array with a variable number of arguments passed to a function that behaves like a constructor.

## 3. Array Type üè∑Ô∏è

How to check if a variable holds an array:

### `typeof` Operator

The `typeof` operator, when used on an array, returns `"object"`.

‚ùó This is because arrays in JavaScript are technically a special type of object.
So, `typeof` alone is not reliable for specifically checking if something is an array.

```javascript
let myArray = [1, 2, 3];
console.log(typeof myArray); // Output: "object"

let myObject = { key: "value" };
console.log(typeof myObject); // Output: "object"
```

### `Array.isArray()` Check ‚úÖ

To reliably check if a value is an array, use the static `Array.isArray()` method.

üéØ Purpose: Specifically designed to determine if a value is an array.

Syntax:
```javascript
Array.isArray(value)
```

Parameters:
*   `value`: The value to be checked.

Returns:
*   `true` if the value is an array.
*   `false` otherwise.

Example:
```javascript
let list = [1, 2, 3];
let obj = { a: 1, b: 2 };
let str = "hello";
let num = 123;
let isNull = null;

console.log(Array.isArray(list));    // Output: true
console.log(Array.isArray(obj));     // Output: false
console.log(Array.isArray(str));     // Output: false
console.log(Array.isArray(num));     // Output: false
console.log(Array.isArray(isNull));  // Output: false
```

## 4. Accessing and Modifying Elements üéØ

### Accessing Elements

You access array elements using bracket notation `[]` with the element's zero-based index.

üóùÔ∏è Key Idea: Indices start from `0` for the first element.

Syntax: `arrayName[index]`

Example:
```javascript
let fruits = ["Apple", "Banana", "Cherry", "Date"];

console.log(fruits[0]); // Output: "Apple" (first element)
console.log(fruits[1]); // Output: "Banana" (second element)
console.log(fruits[3]); // Output: "Date" (last element in this case)

// Accessing an index that doesn't exist returns undefined
console.log(fruits[4]); // Output: undefined
console.log(fruits[-1]); // Output: undefined (negative indices don't work directly like in Python)
```

### Modifying Elements

You can change the value of an element by assigning a new value to it at its specific index.

üîÑ Mutability: Arrays are mutable, meaning their contents can be changed after creation.

Syntax: `arrayName[index] = newValue;`

Example:
```javascript
let colors = ["Red", "Green", "Blue"];
console.log("Original colors:", colors); // Output: Original colors: ["Red", "Green", "Blue"]

colors[1] = "Yellow"; // Modify the element at index 1
console.log("Modified colors:", colors); // Output: Modified colors: ["Red", "Yellow", "Blue"]

// Adding a new element by assigning to an index beyond the current length
colors[3] = "Purple";
console.log("Added Purple:", colors); // Output: Added Purple: ["Red", "Yellow", "Blue", "Purple"]

// If you assign to an index with gaps, intermediate elements become <empty slots> (sparse array)
colors[5] = "Black";
console.log("Added Black with gap:", colors); // Output: ["Red", "Yellow", "Blue", "Purple", <1 empty item>, "Black"]
console.log(colors[4]); // Output: undefined
```

### `.length` Property üìè

The `length` property of an array returns (or sets) the number of elements in an array.
It's always one more than the highest index in the array.

Accessing `length`:
```javascript
let numbers = [10, 20, 30, 40, 50];
console.log(numbers.length); // Output: 5

let emptyArray = [];
console.log(emptyArray.length); // Output: 0
```

Modifying `length`:
üìâ If you set `length` to a value smaller than the current length, the array is truncated (elements beyond the new length are removed).
üìà If you set `length` to a value larger than the current length, the array is extended with empty (undefined) slots.

```javascript
let items = ["A", "B", "C", "D", "E"];
console.log("Initial items:", items, "Length:", items.length); // Initial items: ["A", "B", "C", "D", "E"] Length: 5

// Truncate the array
items.length = 3;
console.log("Truncated items:", items, "Length:", items.length); // Truncated items: ["A", "B", "C"] Length: 3
console.log(items[3]); // Output: undefined

// Extend the array
items.length = 5;
console.log("Extended items:", items, "Length:", items.length); // Extended items: ["A", "B", "C", <2 empty items>] Length: 5
console.log(items[3]); // Output: undefined
console.log(items[4]); // Output: undefined
```

## 5. Copying Arrays üêëüêë

### Why Copy? ü§î

Arrays are reference types in JavaScript.
When you assign an array variable to another (e.g., `let newArray = oldArray;`), you're not creating a new array.
Instead, both variables point to the same array object in memory.
Modifying the array through one variable will affect the other.

```javascript
let original = [1, 2, 3];
let referenceCopy = original; // Both 'original' and 'referenceCopy' point to the SAME array

console.log("Original before modification:", original);         // [1, 2, 3]
console.log("ReferenceCopy before modification:", referenceCopy); // [1, 2, 3]

referenceCopy[0] = 100; // Modify the array using 'referenceCopy'

console.log("Original after modification:", original);           // [100, 2, 3] - Original is also changed!
console.log("ReferenceCopy after modification:", referenceCopy); // [100, 2, 3]
```
To work with an independent copy, you need to explicitly create one.

### Shallow Copy Methods ÏñïÏùÄ Î≥µÏÇ¨

These methods create a shallow copy of an array.

**What is a shallow copy?**
*   A new array is created.
*   Elements from the original array are copied into the new array.
*   If an element is a primitive type (number, string, boolean), its value is copied.
*   If an element is a reference type (object, another array), the reference (memory address) is copied, not the actual object/array. This means both the original and copied array will point to the same nested object/array.

#### Spread Syntax (`...`) ‚ú®

A modern and concise way to create a shallow copy.

Syntax: `let newArray = [...oldArray];`

Example (Primitives):
```javascript
let originalPrimitives = [10, 20, 30];
let copiedPrimitives = [...originalPrimitives];

copiedPrimitives[0] = 100;

console.log("Original Primitives:", originalPrimitives); // Output: [10, 20, 30] (unchanged)
console.log("Copied Primitives:", copiedPrimitives);   // Output: [100, 20, 30]
```

Example (Nested Objects - illustrates shallowness):
```javascript
let originalWithObject = [1, { value: "original" }];
let copiedWithObject = [...originalWithObject];

copiedWithObject[0] = 10; // Modifies primitive in copy only
copiedWithObject[1].value = "modified"; // Modifies nested object; affects original too!

console.log("Original With Object:", originalWithObject);
// Output: [1, { value: "modified" }]
console.log("Copied With Object:", copiedWithObject);
// Output: [10, { value: "modified" }]
```

#### `slice()` Method for Copying üç∞

The `slice()` method, when called without arguments (`oldArray.slice()`), creates a shallow copy of the entire array.

Syntax: `let newArray = oldArray.slice();`

Example:
```javascript
let sourceArray = ["a", "b", { city: "New York" }];
let shallowCopySlice = sourceArray.slice();

shallowCopySlice[0] = "x"; // Affects only the copy
shallowCopySlice[2].city = "London"; // Affects both original and copy for the nested object

console.log("Source Array (slice):", sourceArray);
// Output: ["a", "b", { city: "London" }]
console.log("Shallow Copy (slice):", shallowCopySlice);
// Output: ["x", "b", { city: "London" }]
```

#### `Array.from()` Method for Copying üè≠

`Array.from()` can create a shallow copy from an array-like or iterable object.

Syntax: `let newArray = Array.from(oldArray);`

Example:
```javascript
let initialArray = [10, 20, [100, 200]];
let copyFromArray = Array.from(initialArray);

copyFromArray[0] = 1000; // Affects only the copy
copyFromArray[2][0] = 999; // Affects both for the nested array

console.log("Initial Array (Array.from):", initialArray);
// Output: [10, 20, [999, 200]]
console.log("Copy from Array (Array.from):", copyFromArray);
// Output: [1000, 20, [999, 200]]
```

### Note on Deep Copy üåä (vs. ÏñïÏùÄ)

For arrays containing nested objects or arrays, if you need completely independent copies (where changes to nested structures in the copy don't affect the original), you need a deep copy.

A deep copy recursively copies all nested objects and arrays as well.
There's no single built-in JavaScript method for a generic deep copy.

Common approaches:
*   Manual recursion: Write a function that iterates through the array and its nested structures.
*   `JSON.parse(JSON.stringify(object))`: A common hack, but has limitations (e.g., loses functions, `undefined`, `Date` objects become strings).
```javascript
let originalDeep = [1, { a: 2, d: new Date() }, [3, 4]];
let deepCopyJSON = JSON.parse(JSON.stringify(originalDeep));
// deepCopyJSON[1].d will be a string, not a Date object.
```
*   Libraries: Use utility libraries like Lodash (`_.cloneDeep()`) which provide robust deep cloning functions.

## 6. Iterating Over Arrays üö∂‚Äç‚ôÄÔ∏èüö∂‚Äç‚ôÇÔ∏è

There are several ways to loop through the elements of an array:

### `for` Loop (Traditional) klasik

The classic `for` loop gives you full control over the iteration, including access to the index.

Use Cases:
*   When you need the index for logic within the loop.
*   When you need to iterate in reverse or skip elements based on complex conditions.
*   When you might need to `break` or `continue` based on conditions.

Syntax:
```javascript
for (let i = 0; i < arrayName.length; i++) {
  // Current element: arrayName[i]
  // Current index: i
}
```

Example:
```javascript
let numbers = [10, 20, 30, 40];
console.log("Using traditional for loop:");
for (let i = 0; i < numbers.length; i++) {
  console.log(`Index ${i}: Value ${numbers[i]}, Doubled: ${numbers[i] * 2}`);
}
// Output:
// Index 0: Value 10, Doubled: 20
// Index 1: Value 20, Doubled: 40
// Index 2: Value 30, Doubled: 60
// Index 3: Value 40, Doubled: 80
```

### `for...of` Loop (ES6) üî•

A more modern and often more readable way to iterate directly over the values of an iterable object (like an array).

Use Cases:
*   When you only need the value of each element and not the index.
*   For cleaner syntax when simple iteration over values is needed.

‚ùó Note: You cannot directly get the index within a `for...of` loop unless you use `array.entries()` or a separate counter.

Syntax:
```javascript
for (let element of arrayName) {
  // Current element: element
}
```

Example:
```javascript
let colors = ["Red", "Green", "Blue"];
console.log("\nUsing for...of loop:");
for (let color of colors) {
  console.log(`Color: ${color.toUpperCase()}`);
}
// Output:
// Color: RED
// Color: GREEN
// Color: BLUE

// Getting index with for...of using .entries()
console.log("\nUsing for...of loop with entries():");
for (let [index, color] of colors.entries()) {
    console.log(`Index ${index}: ${color}`);
}
// Output:
// Index 0: Red
// Index 1: Green
// Index 2: Blue
```

### `forEach()` Method for Iteration üîÑ

Executes a provided callback function once for each array element.

Use Cases:
*   When you want to perform an action for each element (side effects like logging, DOM manipulation).
*   Not suitable if you need to break the loop or if you intend to create a new array based on the iteration (use `map` for that).

‚ùó Note: `forEach` always iterates over all elements. You cannot use `break` or `continue` like in a `for` loop. It returns `undefined`.

Syntax (with callback details in the Methods section):
```javascript
arrayName.forEach((element, index, array) => {
  // Your code here
});
```

Example:
```javascript
let fruits = ["Apple", "Banana", "Cherry"];
console.log("\nUsing forEach method:");
fruits.forEach(function(fruit, idx, arr) { // arr is the original fruits array
  console.log(`Fruit at index ${idx}: ${fruit} (from array of length ${arr.length})`);
});
// Output:
// Fruit at index 0: Apple (from array of length 3)
// Fruit at index 1: Banana (from array of length 3)
// Fruit at index 2: Cherry (from array of length 3)
```

## 7. Common Array Methods ‚öôÔ∏è

JavaScript provides a rich set of built-in methods to work with arrays. They can be broadly categorized:

### Mutator Methods (Modify the Original Array) üí•

These methods change the original array they are called on.

#### `push()`
Purpose: Adds one or more elements to the end of an array.

Syntax: `array.push(element1, ..., elementN)`

Parameters:
*   `element1, ..., elementN`: The element(s) to add.

Returns: The new length of the array.

Mutates Original? ‚úÖ Yes.

Use Case: Adding items to a list, like a to-do list or a shopping cart.

Example:
```javascript
let numbers = [1, 2];
console.log("Original numbers:", numbers); // [1, 2]
let newLength = numbers.push(3, 4, 5);
console.log("After push:", numbers);      // Output: [1, 2, 3, 4, 5]
console.log("New length:", newLength);   // Output: 5
```

#### `pop()`
Purpose: Removes the last element from an array.

Syntax: `array.pop()`

Parameters: None.

Returns: The removed element (or `undefined` if the array is empty).

Mutates Original? ‚úÖ Yes.

Use Case: Implementing a LIFO (Last-In, First-Out) stack, getting the last added item.

Example:
```javascript
let fruitsToPop = ["Apple", "Banana", "Cherry"];
console.log("Original fruits:", fruitsToPop); // ["Apple", "Banana", "Cherry"]
let lastFruit = fruitsToPop.pop();
console.log("After pop:", fruitsToPop);      // Output: ["Apple", "Banana"]
console.log("Popped fruit:", lastFruit);   // Output: "Cherry"

let emptyArrPop = [];
console.log(emptyArrPop.pop()); // Output: undefined
```

#### `shift()`
Purpose: Removes the first element from an array.

Syntax: `array.shift()`

Parameters: None.

Returns: The removed element (or `undefined` if the array is empty).

Mutates Original? ‚úÖ Yes. All subsequent elements are shifted to a lower index.

Use Case: Implementing a FIFO (First-In, First-Out) queue, processing items from the beginning.

Example:
```javascript
let colorsToShift = ["Red", "Green", "Blue"];
console.log("Original colors:", colorsToShift); // ["Red", "Green", "Blue"]
let firstColor = colorsToShift.shift();
console.log("After shift:", colorsToShift);      // Output: ["Green", "Blue"]
console.log("Shifted color:", firstColor); // Output: "Red"
```

#### `unshift()`
Purpose: Adds one or more elements to the beginning of an array.

Syntax: `array.unshift(element1, ..., elementN)`

Parameters:
*   `element1, ..., elementN`: The element(s) to add.

Returns: The new length of the array.

Mutates Original? ‚úÖ Yes. Existing elements are shifted to higher indices.

Use Case: Adding high-priority items to the front of a queue.

Example:
```javascript
let tasks = ["Task 2", "Task 3"];
console.log("Original tasks:", tasks); // ["Task 2", "Task 3"]
let newLengthTasks = tasks.unshift("Task 0", "Task 1");
console.log("After unshift:", tasks);      // Output: ["Task 0", "Task 1", "Task 2", "Task 3"]
console.log("New length:", newLengthTasks); // Output: 4
```

#### `splice()`
Purpose: A very versatile method that changes the contents of an array by removing or replacing existing elements and/or adding new elements in place.

Syntax: `array.splice(startIndex, deleteCount, item1, ..., itemN)`

Parameters:
*   `startIndex`: The index at which to start changing the array. Can be negative (counts from the end).
*   `deleteCount` (optional): An integer indicating the number of elements to remove from `startIndex`. If `0` or negative, no elements are removed. If omitted and `startIndex` is provided, all elements from `startIndex` to the end are deleted.
*   `item1, ..., itemN` (optional): The elements to add to the array, beginning from `startIndex`. If you don't specify any elements to add, `splice()` will only remove elements.

Returns: An array containing the deleted elements. If no elements were deleted, an empty array is returned.

Mutates Original? ‚úÖ Yes.

Use Case: Inserting elements, deleting elements, or replacing elements at any position within the array.

Example:
```javascript
let months = ["Jan", "March", "April", "June"];
console.log("Original months:", months);

// 1. Insert "Feb" at index 1 (without deleting anything)
let deleted1 = months.splice(1, 0, "Feb");
console.log("After inserting Feb:", months); // Output: ["Jan", "Feb", "March", "April", "June"]
console.log("Deleted (splice 1):", deleted1); // Output: []

// 2. Replace "April" (at index 3) with "MAY_REPLACED"
// To replace, deleteCount must be 1 or more.
let deleted2 = months.splice(3, 1, "MAY_REPLACED");
console.log("After replacing April:", months); // Output: ["Jan", "Feb", "March", "MAY_REPLACED", "June"]
console.log("Deleted (splice 2):", deleted2); // Output: ["April"]

// 3. Remove 2 elements starting from index 1 ("Feb", "March")
let deleted3 = months.splice(1, 2);
console.log("After removing Feb & March:", months); // Output: ["Jan", "MAY_REPLACED", "June"]
console.log("Deleted (splice 3):", deleted3);   // Output: ["Feb", "March"]

// 4. Add elements without deleting (insert at the end using months.length)
months.splice(months.length, 0, "July", "August");
console.log("After adding July & August:", months); // Output: ["Jan", "MAY_REPLACED", "June", "July", "August"]
```

#### `sort()`
Purpose: Sorts the elements of an array in place.

Syntax: `array.sort(compareFunction)`

Parameters:
*   `compareFunction` (optional): A function that defines the sort order.
    *   If omitted, elements are sorted as strings based on their UTF-16 code units values. This often leads to unexpected results for numbers (e.g., "10" comes before "2").
    *   The `compareFunction(a, b)` should return:
        *   A negative value if `a` should come before `b`.
        *   A positive value if `a` should come after `b`.
        *   `0` if their order relative to each other doesn't change (though this behavior can be inconsistent across browsers for `0`).

Returns: The sorted array (it's the same array reference, now mutated).

Mutates Original? ‚úÖ Yes.

Use Case: Ordering elements alphabetically or numerically. Crucial to provide a `compareFunction` for numerical or custom object sorting.

Example:
```javascript
let fruitsSort = ["Banana", "Orange", "Apple", "Mango"];
console.log("Original fruits:", fruitsSort);
fruitsSort.sort(); // Default sort (alphabetical for strings)
console.log("Sorted fruits:", fruitsSort); // Output: ["Apple", "Banana", "Mango", "Orange"]

let numbersSort = [10, 5, 100, 1, 20, 2];
console.log("\nOriginal numbers:", numbersSort);
numbersSort.sort(); // Default sort (lexicographical/string based for numbers - WRONG!)
console.log("Numbers sorted as strings (incorrect):", numbersSort); // Output: [1, 10, 100, 2, 20, 5]

// Correct numerical sort (ascending)
numbersSort.sort(function(a, b) {
  return a - b; // If a < b, returns negative. If a > b, returns positive.
});
console.log("Numbers sorted numerically (ascending):", numbersSort); // Output: [1, 2, 5, 10, 20, 100]

// Numerical sort (descending) using arrow function
numbersSort.sort((a, b) => b - a);
console.log("Numbers sorted numerically (descending):", numbersSort); // Output: [100, 20, 10, 5, 2, 1]

// Sorting an array of objects
let students = [
  { name: "Eve", age: 22 },
  { name: "Adam", age: 25 },
  { name: "Chris", age: 20 }
];
students.sort((a, b) => a.age - b.age); // Sort by age (ascending)
console.log("\nStudents sorted by age:", students);
// Output: [{ name: "Chris", age: 20 }, { name: "Eve", age: 22 }, { name: "Adam", age: 25 }]

students.sort((a,b) => a.name.localeCompare(b.name)); // Sort by name (alphabetical)
console.log("\nStudents sorted by name:", students);
// Output: [{ name: "Adam", age: 25 }, { name: "Chris", age: 20 }, { name: "Eve", age: 22 }]
```

#### `reverse()`
Purpose: Reverses the order of the elements of an array in place. The first element becomes the last, and the last becomes the first.

Syntax: `array.reverse()`

Parameters: None.

Returns: The reversed array (the same array reference, now mutated).

Mutates Original? ‚úÖ Yes.

Use Case: Inverting the current order of elements.

Example:
```javascript
let letters = ["a", "b", "c", "d", "e"];
console.log("Original letters:", letters);
letters.reverse();
console.log("Reversed letters:", letters); // Output: ["e", "d", "c", "b", "a"]
```

#### `fill()`
Purpose: Changes all elements in an array (or a portion of it) to a static value, in place.

Syntax: `array.fill(value, start, end)`

Parameters:
*   `value`: The value to fill the array with.
*   `start` (optional): Start index (inclusive). Default is `0`.
*   `end` (optional): End index (exclusive). Default is `array.length`.

Returns: The modified array (the same array reference).

Mutates Original? ‚úÖ Yes.

Use Case: Quickly populating an array with a default value, or resetting parts of an array.

Example:
```javascript
let arrFill1 = [1, 2, 3, 4, 5];
console.log("Original arrFill1:", arrFill1);
arrFill1.fill(0, 1, 4); // Fill with 0 from index 1 up to (but not including) index 4
console.log("After fill(0, 1, 4):", arrFill1); // Output: [1, 0, 0, 0, 5]

let arrFill2 = new Array(5); // Creates [<5 empty items>]
console.log("\nOriginal arrFill2:", arrFill2);
arrFill2.fill(true); // Fill the entire array with true
console.log("After fill(true):", arrFill2); // Output: [true, true, true, true, true]

let arrFill3 = [1,2,3,4,5];
arrFill3.fill("X", 2); // Fill from index 2 to the end
console.log("\nAfter fill('X', 2):", arrFill3); // Output: [1,2,"X","X","X"]
```

### Accessor Methods (Return New Array/Value, Don't Modify Original) üõ°Ô∏è

These methods do not change the original array; they return a new array or some other value based on the original.

#### `slice()`
Purpose: Returns a shallow copy of a portion of an array into a new array object.

Syntax: `array.slice(beginIndex, endIndex)`

Parameters:
*   `beginIndex` (optional): Zero-based index at which to begin extraction.
    *   If omitted, defaults to `0`.
    *   A negative index can be used, indicating an offset from the end (e.g., `-1` is the last element).
*   `endIndex` (optional): Zero-based index before which to end extraction (the element at `endIndex` itself is not included).
    *   If omitted, extracts through the end of the array.
    *   A negative index can be used.

Returns: A new array containing the extracted elements.

Mutates Original? ‚ùå No.

Use Case: Extracting sub-arrays, creating shallow copies of an array (if both `beginIndex` and `endIndex` are omitted or `array.slice()` is used).

Example:
```javascript
let animals = ["ant", "bison", "camel", "duck", "elephant", "frog"];
console.log("Original animals:", animals);

let someAnimals = animals.slice(2, 4); // Extracts elements at index 2 and 3
console.log("Slice (2, 4):", someAnimals); // Output: ["camel", "duck"]

let endAnimals = animals.slice(3); // Extracts from index 3 to the end
console.log("Slice (3):", endAnimals); // Output: ["duck", "elephant", "frog"]

let lastTwo = animals.slice(-2); // Extracts the last two elements
console.log("Slice (-2):", lastTwo); // Output: ["elephant", "frog"]

let allButFirstLast = animals.slice(1, -1); // Extracts from index 1 up to (not including) last element
console.log("Slice (1, -1):", allButFirstLast); // Output: ["bison", "camel", "duck", "elephant"]

let shallowCopy = animals.slice(); // Creates a shallow copy of the whole array
console.log("Shallow copy:", shallowCopy); // Output: ["ant", "bison", "camel", "duck", "elephant", "frog"]
console.log("Original animals still intact:", animals);
```

#### `concat()`
Purpose: Used to merge two or more arrays (or values). This method does not change the existing arrays but instead returns a new array.

Syntax: `array.concat(value1, value2, ..., valueN)`

Parameters:
*   `value1, ..., valueN`: Arrays and/or values to concatenate. If a value is not an array, it's added as a single element. If it is an array, its elements are spread out.

Returns: A new array instance.

Mutates Original? ‚ùå No.

Use Case: Combining multiple arrays or adding individual elements to form a new, larger array.

Example:
```javascript
let arrA = [1, 2];
let arrB = [3, 4];
let arrC = ["a", "b"];
let valueX = 100;

console.log("arrA:", arrA);
console.log("arrB:", arrB);

let combined1 = arrA.concat(arrB);
console.log("arrA.concat(arrB):", combined1); // Output: [1, 2, 3, 4]

let combined2 = arrA.concat(arrB, arrC, valueX, "hello");
console.log("Combined with more:", combined2); // Output: [1, 2, 3, 4, "a", "b", 100, "hello"]

// Concatenating nested arrays (concat does a shallow merge)
let nestedArr = [[5, 6]];
let combinedNested = arrA.concat(nestedArr);
console.log("Combined with nested:", combinedNested); // Output: [1, 2, [5, 6]]
// To flatten, you'd use .flat() or spread within concat: arrA.concat(...nestedArr)

console.log("Original arrA still intact:", arrA);
```

#### `join()`
Purpose: Adds all the elements of an array into a string, separated by a specified separator.

Syntax: `array.join(separator)`

Parameters:
*   `separator` (optional): A string to separate each element. If omitted, a comma (`,`) is used by default. If `separator` is an empty string (`""`), elements are joined without any characters in between.

Returns: A string. If the array is empty, an empty string is returned.

Mutates Original? ‚ùå No.

Use Case: Creating a display string from array elements, like a comma-separated list.

Example:
```javascript
let elements = ["Fire", "Air", "Water", "Earth"];
console.log("Original elements:", elements);

let joinedDefault = elements.join();
console.log("Joined (default comma):", joinedDefault); // Output: "Fire,Air,Water,Earth"

let joinedNoSpace = elements.join("");
console.log("Joined (empty string):", joinedNoSpace); // Output: "FireAirWaterEarth"

let joinedWithDash = elements.join(" - ");
console.log("Joined (with ' - '):", joinedWithDash); // Output: "Fire - Air - Water - Earth"

let emptyJoin = [].join("-");
console.log("Joined empty array:", emptyJoin); // Output: ""
console.log("Original elements still intact:", elements);
```

#### `indexOf()`
Purpose: Returns the first index at which a given element can be found in the array.

Syntax: `array.indexOf(searchElement, fromIndex)`

Parameters:
*   `searchElement`: The element to locate in the array. Uses strict equality (`===`) for comparison.
*   `fromIndex` (optional): The index to start the search at. Defaults to `0`. If negative, it's an offset from the end.

Returns: The first index of the `searchElement`, or `-1` if it is not found.

Mutates Original? ‚ùå No.

Use Case: Checking if an element exists and finding its first occurrence.

Example:
```javascript
let beasts = ["ant", "bison", "camel", "duck", "bison", "elk"];
console.log("Original beasts:", beasts);

console.log("indexOf('bison'):", beasts.indexOf("bison")); // Output: 1 (first occurrence)
console.log("indexOf('bison', 2):", beasts.indexOf("bison", 2)); // Output: 4 (starts search from index 2)
console.log("indexOf('giraffe'):", beasts.indexOf("giraffe")); // Output: -1 (not found)
console.log("indexOf('elk', -2):", beasts.indexOf("elk", -2)); // Output: 5 (starts search from 2nd to last element)
console.log("indexOf('ant', -7):", beasts.indexOf("ant", -7)); // Output: 0 (negative index clamped to 0 if too large)

// indexOf does NOT find NaN
let nanArray = [1, NaN, 3];
console.log("indexOf(NaN):", nanArray.indexOf(NaN)); // Output: -1
```

#### `lastIndexOf()`
Purpose: Returns the last index at which a given element can be found in the array. The array is searched backwards from `fromIndex`.

Syntax: `array.lastIndexOf(searchElement, fromIndex)`

Parameters:
*   `searchElement`: Element to locate. Uses strict equality (`===`).
*   `fromIndex` (optional): The index at which to start searching backwards. Defaults to `array.length - 1` (i.e., the end of the array). If negative, it's an offset from the end.

Returns: The last index of the `searchElement`, or `-1` if not found.

Mutates Original? ‚ùå No.

Use Case: Finding the last occurrence of an element.

Example:
```javascript
let animalsAgain = ["Dodo", "Tiger", "Penguin", "Dodo", "Lion", "Dodo"];
console.log("Original animalsAgain:", animalsAgain);

console.log("lastIndexOf('Dodo'):", animalsAgain.lastIndexOf("Dodo")); // Output: 5 (last occurrence)
console.log("lastIndexOf('Dodo', 3):", animalsAgain.lastIndexOf("Dodo", 3)); // Output: 3 (searches backward from index 3)
console.log("lastIndexOf('Dodo', 0):", animalsAgain.lastIndexOf("Dodo", 0)); // Output: 0
console.log("lastIndexOf('Tiger'):", animalsAgain.lastIndexOf("Tiger")); // Output: 1
console.log("lastIndexOf('Giraffe'):", animalsAgain.lastIndexOf("Giraffe")); // Output: -1
```

#### `includes()` (ES7)
Purpose: Determines whether an array includes a certain value among its entries.

Syntax: `array.includes(valueToFind, fromIndex)`

Parameters:
*   `valueToFind`: The value to search for. `includes()` is able to find `NaN`, unlike `indexOf()`.
*   `fromIndex` (optional): The position in this array at which to begin searching. Defaults to `0`.

Returns: `true` if `valueToFind` is found; otherwise, `false`.

Mutates Original? ‚ùå No.

Use Case: A more readable and often preferred way to check for an element's existence, especially when dealing with `NaN`.

Example:
```javascript
let pets = ["cat", "dog", "bat", NaN];
console.log("Original pets:", pets);

console.log("includes('cat'):", pets.includes("cat"));        // Output: true
console.log("includes('hamster'):", pets.includes("hamster"));  // Output: false
console.log("includes('dog', 1):", pets.includes("dog", 1));   // Output: true (starts search from index 1)
console.log("includes('dog', 2):", pets.includes("dog", 2));   // Output: false

// includes() correctly handles NaN
console.log("includes(NaN):", pets.includes(NaN));          // Output: true
```

### Iteration Methods (Often Involve Callbacks) üßë‚Äçü§ù‚Äçüßë

These methods typically take a callback function as an argument and apply it to elements of the array. They often return a new array or a single value, and generally do not mutate the original array (though the callback itself could, if poorly designed).

#### `forEach()`
Purpose: Executes a provided callback function once for each array element.

Syntax: `array.forEach(callbackFunction(currentValue, index, array), thisArg)`

Parameters:
*   `callbackFunction`: Function to execute on each element, taking three arguments:
    *   `currentValue`: The current element being processed.
    *   `index` (optional): The index of `currentValue`.
    *   `array` (optional): The array `forEach()` was called upon.
*   `thisArg` (optional): Value to use as `this` when executing `callbackFunction`.

Returns: `undefined`. (It's used for side effects, not for generating a new array).

Mutates Original? ‚ùå No (by `forEach` itself, but the `callbackFunction` can).

Use Case: Iterating to perform actions like logging, DOM updates, or calling other functions for each element. Not for creating a new array (use `map` for that). You cannot `break` or `continue` a `forEach` loop.

Example:
```javascript
let itemsList = ["Book", "Pen", "Laptop"];
console.log("Using forEach:");
itemsList.forEach(function(item, index, originalArray) {
  console.log(`Processing item: ${item} at index ${index}. Original array length: ${originalArray.length}`);
});
// Output:
// Processing item: Book at index 0. Original array length: 3
// Processing item: Pen at index 1. Original array length: 3
// Processing item: Laptop at index 2. Original array length: 3

let sum = 0;
const numbersForEach = [10, 20, 30];
numbersForEach.forEach(num => sum += num);
console.log("Sum calculated with forEach:", sum); // Output: 60
```

#### `map()`
Purpose: Creates a new array populated with the results of calling a provided callback function on every element in the calling array.

Syntax: `array.map(callbackFunction(currentValue, index, array), thisArg)`

Parameters:
*   `callbackFunction`: Function that produces an element of the new array. It should return a value. Arguments are:
    *   `currentValue`: The current element being processed.
    *   `index` (optional): The index of `currentValue`.
    *   `array` (optional): The array `map()` was called upon.
*   `thisArg` (optional): Value to use as `this` when executing `callbackFunction`.

Returns: A new array of the same length as the original, with transformed elements.

Mutates Original? ‚ùå No.

Use Case: Transforming each element of an array into something new (e.g., squaring numbers, extracting properties from objects, formatting strings).

Example:
```javascript
let numbersToSquare = [1, 2, 3, 4, 5];
console.log("Original numbersToSquare:", numbersToSquare);
let squaredNumbers = numbersToSquare.map(function(number) {
  return number * number;
});
console.log("Squared numbers (new array):", squaredNumbers); // Output: [1, 4, 9, 16, 25]
console.log("Original numbersToSquare (unchanged):", numbersToSquare);

let users = [
  { id: 1, firstName: "Alice", lastName: "Smith" },
  { id: 2, firstName: "Bob", lastName: "Johnson" }
];
let fullNames = users.map(user => `${user.firstName} ${user.lastName}`);
console.log("User full names:", fullNames); // Output: ["Alice Smith", "Bob Johnson"]
```

#### `filter()`
Purpose: Creates a new array with all elements that pass the test implemented by the provided callback function.

Syntax: `array.filter(callbackFunction(element, index, array), thisArg)`

Parameters:
*   `callbackFunction`: Function to test each element. Should return `true` to keep the element, or `false` to discard it. Arguments:
    *   `element`: The current element being processed.
    *   `index` (optional): The index of `element`.
    *   `array` (optional): The array `filter()` was called upon.
*   `thisArg` (optional): Value to use as `this` when executing `callbackFunction`.

Returns: A new array containing only the elements for which the callback returned `true`. If no elements pass, an empty array is returned.

Mutates Original? ‚ùå No.

Use Case: Selecting a subset of elements based on one or more conditions.

Example:
```javascript
let scores = [10, 50, 23, 78, 92, 15, 60];
console.log("Original scores:", scores);
let passingScores = scores.filter(function(score) {
  return score >= 50; // Condition to keep the element
});
console.log("Passing scores (new array):", passingScores); // Output: [50, 78, 92, 60]
console.log("Original scores (unchanged):", scores);

let words = ["spray", "limit", "elite", "exuberant", "destruction", "present"];
const longWords = words.filter(word => word.length > 6);
console.log("Long words:", longWords); // Output: ["exuberant", "destruction", "present"]
```

#### `find()` (ES6)
Purpose: Returns the value of the first element in the array that satisfies the provided testing callback function.

Syntax: `array.find(callbackFunction(element, index, array), thisArg)`

Parameters:
*   `callbackFunction`: Function to execute on each element. Should return `true` if the element is a match. Arguments:
    *   `element`: The current element.
    *   `index` (optional): Index of `element`.
    *   `array` (optional): The array `find()` was called upon.
*   `thisArg` (optional): `this` value for `callbackFunction`.

Returns: The value of the first matching element, or `undefined` if no element is found.

Mutates Original? ‚ùå No.

Use Case: Finding a single specific element in an array based on a condition. Stops searching once the first match is found.

Example:
```javascript
let inventory = [
  { name: "apples", quantity: 2 },
  { name: "bananas", quantity: 0 },
  { name: "cherries", quantity: 5 },
  { name: "bananas", quantity: 10 } // Another banana
];
console.log("Original inventory:", inventory);

let foundBanana = inventory.find(fruit => fruit.name === "bananas");
console.log("Found banana:", foundBanana); // Output: { name: 'bananas', quantity: 0 } (the first one)

let foundOrange = inventory.find(fruit => fruit.name === "oranges");
console.log("Found orange:", foundOrange); // Output: undefined

let numbersFind = [10, 25, 3, 40, 17];
let firstLargeNum = numbersFind.find(num => num > 20);
console.log("First number > 20:", firstLargeNum); // Output: 25
```

#### `findIndex()` (ES6)
Purpose: Returns the index of the first element in the array that satisfies the provided testing callback function.

Syntax: `array.findIndex(callbackFunction(element, index, array), thisArg)`

Parameters: Same as `find()`.

Returns: The index of the first matching element, or `-1` if no element is found.

Mutates Original? ‚ùå No.

Use Case: Similar to `find()`, but when you need the position (index) of the element rather than its value.

Example:
```javascript
let numbersFindIndex = [5, 12, 8, 130, 44, 12];
console.log("Original numbersFindIndex:", numbersFindIndex);

let isLargeNumberIndex = numbersFindIndex.findIndex(element => element > 100);
console.log("Index of first number > 100:", isLargeNumberIndex); // Output: 3 (index of 130)

let indexOfTwelve = numbersFindIndex.findIndex(element => element === 12);
console.log("Index of first '12':", indexOfTwelve); // Output: 1

let indexOfMissing = numbersFindIndex.findIndex(element => element === 999);
console.log("Index of '999':", indexOfMissing); // Output: -1
```

#### `every()`
Purpose: Tests whether all elements in the array pass the test implemented by the provided callback function.

Syntax: `array.every(callbackFunction(element, index, array), thisArg)`

Parameters: Same as `filter()`.

Returns: `true` if the `callbackFunction` returns a truthy value for every array element. Otherwise, `false`. (It short-circuits: stops iterating as soon as the callback returns `false` for an element).

Mutates Original? ‚ùå No.

Use Case: Validating if all items in a collection meet a specific criterion.

Example:
```javascript
let ages = [22, 30, 19, 45, 25];
console.log("Original ages:", ages);
let allAdults = ages.every(age => age >= 18);
console.log("Are all adults (>= 18)?", allAdults); // Output: true

let mixedAges = [22, 17, 30, 19];
let allAdultsMixed = mixedAges.every(age => age >= 18);
console.log("Are all adults in mixedAges?", allAdultsMixed); // Output: false (because of 17)

// Empty array always returns true for every()
console.log("every() on empty array:", [].every(x => x > 0)); // Output: true
```

#### `some()`
Purpose: Tests whether at least one element in the array passes the test implemented by the provided callback function.

Syntax: `array.some(callbackFunction(element, index, array), thisArg)`

Parameters: Same as `filter()`.

Returns: `true` if the `callbackFunction` returns a truthy value for at least one element. Otherwise, `false`. (It short-circuits: stops iterating as soon as the callback returns `true`).

Mutates Original? ‚ùå No.

Use Case: Checking if any item in a collection meets a specific criterion.

Example:
```javascript
let numbersSome = [1, 3, 5, 8, 9];
console.log("Original numbersSome:", numbersSome);
let hasEvenNumber = numbersSome.some(num => num % 2 === 0);
console.log("Does it have at least one even number?", hasEvenNumber); // Output: true (because of 8)

let allOddNumbers = [1, 3, 5, 7, 9];
let hasEvenInOdds = allOddNumbers.some(num => num % 2 === 0);
console.log("Does [1,3,5,7,9] have an even number?", hasEvenInOdds); // Output: false

// Empty array always returns false for some()
console.log("some() on empty array:", [].some(x => x > 0)); // Output: false
```

#### `reduce()`
Purpose: Executes a user-supplied "reducer" callback function on each element of the array, passing in the return value from the calculation on the preceding element. The final result is a single accumulated value.

Syntax: `array.reduce(callbackFunction(accumulator, currentValue, currentIndex, array), initialValue)`

Parameters:
*   `callbackFunction`: Function to execute on each element, taking four arguments:
    *   `accumulator` (or `acc`): The value accumulated so far (or `initialValue` on the first call).
    *   `currentValue` (or `curr`): The current element being processed.
    *   `currentIndex` (optional): The index of `currentValue`.
    *   `array` (optional): The array `reduce()` was called upon.
*   `initialValue` (optional): A value to use as the first argument (accumulator) to the first call of the callback.
    *   If `initialValue` is provided, the callback starts with `currentValue` as the first element.
    *   If `initialValue` is not provided, the first element of the array is used as the `initialValue` for the accumulator, and iteration starts from the second element as `currentValue`. The callback is not invoked for the first element if no initial value is provided. This can lead to errors if the array is empty and no `initialValue` is given.

Returns: The single accumulated value.

Mutates Original? ‚ùå No.

Use Case: Very powerful for summing numbers, flattening arrays, grouping objects, counting occurrences, and many other data transformations that result in a single output.

Example:
```javascript
// 1. Summing all numbers
let numbersToSum = [1, 2, 3, 4, 5];
console.log("Original numbersToSum:", numbersToSum);
let sumOfNumbers = numbersToSum.reduce(
  (accumulator, currentValue) => {
    console.log(`acc: ${accumulator}, curr: ${currentValue}`);
    return accumulator + currentValue;
  },
  0 // initialValue for accumulator
);
console.log("Sum of numbers:", sumOfNumbers); // Output: 15

// 2. Summing without initialValue (array must not be empty)
let sumWithoutInitial = [10, 20, 30].reduce((acc, curr) => acc + curr);
console.log("\nSum without initial value:", sumWithoutInitial); // Output: 60

// 3. Flattening an array of arrays
let nestedArray = [[0, 1], [2, 3], [4, 5]];
console.log("\nOriginal nestedArray:", nestedArray);
let flattened = nestedArray.reduce(
  (accumulator, currentValue) => accumulator.concat(currentValue),
  [] // initialValue is an empty array
);
console.log("Flattened array:", flattened); // Output: [0, 1, 2, 3, 4, 5]

// 4. Counting instances of values
let fruitBasket = ['apple', 'banana', 'orange', 'apple', 'orange', 'apple'];
console.log("\nOriginal fruitBasket:", fruitBasket);
let fruitCounts = fruitBasket.reduce((acc, fruit) => {
  acc[fruit] = (acc[fruit] || 0) + 1;
  return acc;
}, {}); // initialValue is an empty object
console.log("Fruit counts:", fruitCounts); // Output: {apple: 3, banana: 1, orange: 2}

// 5. Grouping objects by a property
let people = [
  { name: "Alice", age: 21, city: "New York" },
  { name: "Max", age: 20, city: "London" },
  { name: "Jane", age: 20, city: "New York" }
];
console.log("\nOriginal people:", people);
let groupedByCity = people.reduce((acc, person) => {
  let city = person.city;
  if (!acc[city]) {
    acc[city] = [];
  }
  acc[city].push(person);
  return acc;
}, {});
console.log("Grouped by city:", groupedByCity);
/* Output:
{
  'New York': [
    { name: 'Alice', age: 21, city: 'New York' },
    { name: 'Jane', age: 20, city: 'New York' }
  ],
  'London': [ { name: 'Max', age: 20, city: 'London' } ]
}
*/
```

#### `reduceRight()`
Purpose: Similar to `reduce()`, but it applies the callback function against an accumulator and each value of the array from right-to-left.

Syntax: `array.reduceRight(callbackFunction(accumulator, currentValue, currentIndex, array), initialValue)`

Parameters: Same as `reduce()`.

Returns: The single accumulated value.

Mutates Original? ‚ùå No.

Use Case: When the order of processing from right-to-left is important for the accumulation logic.

Example:
```javascript
let wordsToCombine = ["world", " ", "Hello"];
console.log("Original wordsToCombine:", wordsToCombine);
// Using reduce (left-to-right)
let greetingLeft = wordsToCombine.reduce((acc, curr) => acc + curr);
console.log("reduce (left-to-right):", greetingLeft); // Output: "world Hello"

// Using reduceRight (right-to-left)
let greetingRight = wordsToCombine.reduceRight((acc, curr) => {
    console.log(`acc: '${acc}', curr: '${curr}'`);
    return acc + curr;
});
console.log("reduceRight (right-to-left):", greetingRight); // Output: "Hello world"
/*
acc: 'Hello', curr: ' '
acc: 'Hello ', curr: 'world'
*/

// Example: composing functions (f(g(h(x))))
const double = x => x * 2;
const add5 = x => x + 5;
const subtract1 = x => x - 1;
const functions = [subtract1, add5, double]; // Apply double, then add5, then subtract1
const composedFunction = functions.reduceRight((acc, f) => x => acc(f(x)));
console.log("\nComposed function result (5):", composedFunction(5)); // subtract1(add5(double(5))) = subtract1(add5(10)) = subtract1(15) = 14
```

#### `flat()` (ES2019)
Purpose: Creates a new array with all sub-array elements concatenated into it recursively up to the specified depth.

Syntax: `array.flat(depth)`

Parameters:
*   `depth` (optional): The depth level specifying how deep a nested array structure should be flattened. Defaults to `1`. Use `Infinity` to flatten all nested arrays regardless of depth.

Returns: A new, flattened array.

Mutates Original? ‚ùå No.

Use Case: Simplifying nested array structures into a single-level array.

Example:
```javascript
let arrFlat1 = [1, 2, [3, 4]];
console.log("Original arrFlat1:", arrFlat1);
console.log("arrFlat1.flat():", arrFlat1.flat()); // Output: [1, 2, 3, 4] (default depth 1)

let arrFlat2 = [1, 2, [3, 4, [5, 6, [7, 8]]]];
console.log("\nOriginal arrFlat2:", arrFlat2);
console.log("arrFlat2.flat():", arrFlat2.flat());       // Output: [1, 2, 3, 4, [5, 6, [7, 8]]] (depth 1)
console.log("arrFlat2.flat(2):", arrFlat2.flat(2));      // Output: [1, 2, 3, 4, 5, 6, [7, 8]] (depth 2)
console.log("arrFlat2.flat(Infinity):", arrFlat2.flat(Infinity)); // Output: [1, 2, 3, 4, 5, 6, 7, 8]

// flat() also removes empty slots (holes) in sparse arrays
let arrWithEmptySlots = [1, 2, , 4, [5, , 6]];
console.log("\nOriginal arrWithEmptySlots:", arrWithEmptySlots);
console.log("arrWithEmptySlots.flat():", arrWithEmptySlots.flat());  // Output: [1, 2, 4, 5, 6]
```

#### `flatMap()` (ES2019)
Purpose: First maps each element using a mapping function, then flattens the result into a new array. It is equivalent to `array.map(...args).flat(1)`, but slightly more efficient as it performs mapping and flattening in one pass.

Syntax: `array.flatMap(callbackFunction(currentValue, index, array), thisArg)`

Parameters:
*   `callbackFunction`: Function that produces an element of the new array. It can return an array (which will be flattened by one level) or a single value (which will be treated as an array with one element for flattening purposes).
    *   `currentValue`: The current element.
    *   `index` (optional): Index of `currentValue`.
    *   `array` (optional): The array `flatMap()` was called upon.
*   `thisArg` (optional): `this` value for `callbackFunction`.

Returns: A new array with each element being the result of the callback function and then flattened to a depth of `1`.

Mutates Original? ‚ùå No.

Use Case: Useful when your mapping operation naturally results in an array for each element, and you want a single flat list as the final output.

Example:
```javascript
let phrases = ["hello world", "goodbye all", "javascript is fun"];
console.log("Original phrases:", phrases);

// Split each phrase into words, then flatten the resulting array of arrays
let wordsFromPhrases = phrases.flatMap(phrase => phrase.split(" "));
console.log("Words from phrases (flatMap):", wordsFromPhrases);
// Output: ["hello", "world", "goodbye", "all", "javascript", "is", "fun"]

// Compare with map followed by flat(1)
let mappedThenFlat = phrases.map(phrase => phrase.split(" ")).flat(); // or .flat(1)
console.log("Words (map then flat):", mappedThenFlat);
// Output: ["hello", "world", "goodbye", "all", "javascript", "is", "fun"]

// Example: duplicate positive numbers, return empty array (which flatMap removes) for negatives
let numbersMapFlat = [1, 2, -3, 4, -5, 0];
console.log("\nOriginal numbersMapFlat:", numbersMapFlat);
let processedNums = numbersMapFlat.flatMap(num => {
  if (num > 0) return [num, num * 10]; // Return an array for positive numbers
  if (num === 0) return [0];            // Return a single element array for zero
  return [];                          // Return an empty array for negative numbers (gets flattened out)
});
console.log("Processed numbers (flatMap):", processedNums);
// Output: [1, 10, 2, 20, 0, 4, 40]
```

### Static Methods (Called on `Array` itself) üèõÔ∏è

These methods are called directly on the `Array` constructor (e.g., `Array.from()`), not on an array instance (e.g., `myArray.from()` would be incorrect).

#### `Array.from()`
Purpose: Creates a new, shallow-copied `Array` instance from an array-like or iterable object.

Syntax:
```javascript
Array.from(arrayLikeOrIterable, mapFunction, thisArg)
```

Parameters:
*   `arrayLikeOrIterable`: An object that is array-like (has a `length` property and indexed elements like `arguments` or a `NodeList`) or an iterable object (like `String`, `Set`, `Map`).
*   `mapFunction` (optional): A map function to call on every element of the array being created.
*   `thisArg` (optional): Value to use as `this` when executing `mapFunction`.

Returns: A new `Array` instance.

Description & Use Case: Converting various data structures (that aren't true arrays but behave like them) into actual arrays. Useful for then using array methods on them. Can also combine creation and mapping.

Example:
```javascript
// 1. From a String
let str = "hello";
let arrFromStr = Array.from(str);
console.log("Array from string 'hello':", arrFromStr); // Output: ["h", "e", "l", "l", "o"]

// 2. From a Set (removes duplicates and creates an array)
const mySet = new Set(["apple", "banana", "apple", "orange"]);
let arrFromSet = Array.from(mySet);
console.log("\nArray from Set:", arrFromSet); // Output: ["apple", "banana", "orange"]

// 3. From an array-like object (e.g., arguments object in a non-arrow function)
function getArgsArray() {
  return Array.from(arguments);
}
console.log("\nArray from arguments:", getArgsArray(10, "test", true)); // Output: [10, "test", true]

// 4. Using a map function during creation
let arrFromMap = Array.from([1, 2, 3, 4], x => x * x);
console.log("\nArray from [1,2,3,4] with map x*x:", arrFromMap); // Output: [1, 4, 9, 16]

// 5. Creating a range of numbers
let range = Array.from({ length: 5 }, (value, index) => index + 1); // value is undefined here
console.log("\nRange of numbers (1-5):", range); // Output: [1, 2, 3, 4, 5]
```

#### `Array.isArray()` (Static)
Purpose: Determines whether the passed value is an `Array`. (Already covered in detail in [Array Type](#3-array-type-%F0%9F%8F%B7%EF%B8%8F) section).

Syntax: `Array.isArray(value)`

Returns: `true` if `value` is an `Array`; otherwise, `false`.

Example:
```javascript
console.log("\nIs [1,2,3] an array?", Array.isArray([1, 2, 3]));  // true
console.log("Is {foo: 123} an array?", Array.isArray({foo: 123})); // false
console.log("Is 'foobar' an array?", Array.isArray('foobar'));   // false
```

#### `Array.of()` (ES6)
Purpose: Creates a new `Array` instance with a variable number of arguments, regardless of the number or type of the arguments.

Difference from `new Array()` constructor:
*   `Array.of(7)` creates an array with a single element: `[7]`.
*   `new Array(7)` creates an empty array with `length` 7: `[ <7 empty items> ]`.

Syntax: `Array.of(element0, element1, ..., elementN)`

Parameters:
*   `element0, ..., elementN`: Elements to include in the new array.

Returns: A new `Array` instance.

Description & Use Case: A more predictable way to create arrays, especially when you might pass a single number as an argument and want that number to be an element, not the length.

Example:
```javascript
console.log("\nArray.of(7):", Array.of(7));       // Output: [7]
console.log("new Array(7):", new Array(7));   // Output: [<7 empty items>] (length 7)

console.log("\nArray.of(1, 2, 3):", Array.of(1, 2, 3)); // Output: [1, 2, 3]
console.log("new Array(1, 2, 3):", new Array(1, 2, 3)); // Output: [1, 2, 3] (same for multiple args)

console.log("\nArray.of('apple', 'banana'):", Array.of('apple', 'banana')); // Output: ['apple', 'banana']
console.log("Array.of(undefined):", Array.of(undefined)); // Output: [undefined]
```

## 8. Advanced Array Concepts (Briefly) üåå

### Multi-dimensional Arrays ‚ñ¶

JavaScript doesn't have true multi-dimensional arrays (like fixed-size matrices in some languages). However, you can create arrays of arrays to achieve similar functionality.

Concept: An array where each element is another array.

Creation & Access:
```javascript
// 2D Array (Array of arrays) - like a matrix or grid
let matrix = [
  [1, 2, 3],  // Row 0
  [4, 5, 6],  // Row 1
  [7, 8, 9]   // Row 2
];

console.log("\nMatrix:", matrix);
console.log("Element at matrix[0][0]:", matrix[0][0]); // Output: 1 (Row 0, Column 0)
console.log("Element at matrix[1][2]:", matrix[1][2]); // Output: 6 (Row 1, Column 2)
console.log("Row 1:", matrix[1]);                     // Output: [4, 5, 6]

// Modifying an element
matrix[0][0] = 100;
console.log("Modified matrix[0][0]:", matrix[0][0]); // Output: 100
console.log("Matrix after modification:", matrix);

// Iterating through a 2D array
console.log("\nIterating through matrix:");
for (let i = 0; i < matrix.length; i++) { // Iterate over rows
  for (let j = 0; j < matrix[i].length; j++) { // Iterate over columns in current row
    console.log(`matrix[${i}][${j}] = ${matrix[i][j]}`);
  }
}
```
Inner arrays can have different lengths, creating "jagged" arrays.

### Sparse Arrays üï≥Ô∏è

Arrays can have "holes" or empty slots, meaning indices for which no value has ever been assigned. These are called sparse arrays.

Creation:
*   Omitting elements in an array literal: `let sparse = [1, , 3];` (index `1` is an empty slot)
*   Using the `Array` constructor with a length: `let sparse = new Array(5);` (all 5 slots are empty)
*   Increasing the `length` property beyond current elements.
*   Using `delete array[index];` (creates an empty slot, doesn't re-index).

Behavior:
*   Accessing an empty slot typically yields `undefined`.
*   Many array iteration methods (`forEach`, `map`, `filter`, `every`, `some`) skip empty slots.
*   A traditional `for` loop will encounter `undefined` for these slots.
*   The `in` operator can check if an index actually has a property (e.g., `1 in sparse` would be `false` for `[1, , 3]`).

Example:
```javascript
let sparseArr = [10, , 30, , 50];
console.log("\nSparse array:", sparseArr);
console.log("Length:", sparseArr.length); // Output: 5
console.log("sparseArr[1]:", sparseArr[1]);     // Output: undefined
console.log("Is index 1 in sparseArr?", 1 in sparseArr);   // Output: false (it's an empty slot)
console.log("Is index 0 in sparseArr?", 0 in sparseArr);   // Output: true

console.log("\nIterating sparseArr with forEach (skips empty slots):");
sparseArr.forEach((val, idx) => console.log(`Index ${idx}: ${val}`));
// Output:
// Index 0: 10
// Index 2: 30
// Index 4: 50

console.log("\nIterating sparseArr with for loop (shows undefined for empty):");
for (let i = 0; i < sparseArr.length; i++) {
  console.log(`Index ${i}: ${sparseArr[i]}`);
}
// Output:
// Index 0: 10
// Index 1: undefined
// Index 2: 30
// Index 3: undefined
// Index 4: 50

delete sparseArr[0]; // Creates an empty slot at index 0
console.log("\nAfter deleting sparseArr[0]:", sparseArr); // [<1 empty item>, , 30, , 50]
console.log("Is index 0 in sparseArr now?", 0 in sparseArr); // Output: false
```

‚ö†Ô∏è Caution: Sparse arrays can sometimes lead to unexpected behavior or performance considerations if not handled carefully. It's often clearer to explicitly fill array slots with `undefined` or `null` if a placeholder is needed, rather than relying on empty slots, to make intent more obvious. Methods like `fill()` or `Array.from()` can help create non-sparse arrays.

üöÄ This covers the essentials and many common methods of JavaScript arrays! Mastering these will be very beneficial for your DSA journey. Good luck!
```
